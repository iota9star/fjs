// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'value.dart';
part 'js.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `from_promise_result`, `from_result`, `into`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `cmp`, `eq`, `fmt`, `fmt`, `hash`, `partial_cmp`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JsAsyncContext>>
abstract class JsAsyncContext implements RustOpaqueInterface {
  Future<JsEvalResult> eval({required String code});

  Future<JsEvalResult> evalFile({required String path});

  Future<JsEvalResult> evalFileWithOptions(
      {required String path, required JsEvalOptions options});

  Future<JsEvalResult> evalFunction(
      {required String module, required String method, List<JsValue>? params});

  Future<JsEvalResult> evalWithOptions(
      {required String code, required JsEvalOptions options});

  static Future<JsAsyncContext> from({required JsAsyncRuntime rt}) =>
      LibFjs.instance.api.crateApiJsJsAsyncContextFrom(rt: rt);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JsAsyncRuntime>>
abstract class JsAsyncRuntime implements RustOpaqueInterface {
  Future<bool> executePendingJob();

  Future<void> idle();

  Future<bool> isJobPending();

  Future<MemoryUsage> memoryUsage();

  factory JsAsyncRuntime() => LibFjs.instance.api.crateApiJsJsAsyncRuntimeNew();

  Future<void> runGc();

  Future<void> setGcThreshold({required BigInt threshold});

  Future<void> setInfo({required String info});

  Future<void> setMaxStackSize({required BigInt limit});

  Future<void> setMemoryLimit({required BigInt limit});

  Future<void> setModules({required List<JsModule> modules});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JsContext>>
abstract class JsContext implements RustOpaqueInterface {
  JsEvalResult eval({required String code});

  JsEvalResult evalFile({required String path});

  JsEvalResult evalFileWithOptions(
      {required String path, required JsEvalOptions options});

  JsEvalResult evalWithOptions(
      {required String code, required JsEvalOptions options});

  factory JsContext({required JsRuntime rt}) =>
      LibFjs.instance.api.crateApiJsJsContextNew(rt: rt);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JsRuntime>>
abstract class JsRuntime implements RustOpaqueInterface {
  bool executePendingJob();

  bool isJobPending();

  MemoryUsage memoryUsage();

  factory JsRuntime() => LibFjs.instance.api.crateApiJsJsRuntimeNew();

  void runGc();

  void setDumpFlags({required BigInt flags});

  void setGcThreshold({required BigInt threshold});

  void setInfo({required String info});

  void setMaxStackSize({required BigInt limit});

  void setMemoryLimit({required BigInt limit});

  Future<void> setModules({required List<JsModule> modules});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryUsage>>
abstract class MemoryUsage implements RustOpaqueInterface {}

@freezed
@immutable
class JsEvalOptions with _$JsEvalOptions {
  const JsEvalOptions._();
  const factory JsEvalOptions.raw({
    required bool global,
    required bool strict,
    required bool backtraceBarrier,
    required bool promise,
  }) = _JsEvalOptions;
  factory JsEvalOptions() => LibFjs.instance.api.crateApiJsJsEvalOptionsNew();
}

@freezed
sealed class JsEvalResult with _$JsEvalResult {
  const JsEvalResult._();

  const factory JsEvalResult.ok(
    JsValue field0,
  ) = JsEvalResult_Ok;
  const factory JsEvalResult.err(
    String field0,
  ) = JsEvalResult_Err;

  bool get isOk => this is JsEvalResult_Ok;
  bool get isErr => this is JsEvalResult_Err;
  JsValue get ok => (this as JsEvalResult_Ok).field0;
  String get err => (this as JsEvalResult_Err).field0;
}

@freezed
sealed class JsModule with _$JsModule {
  const JsModule._();

  const factory JsModule.code(
    String field0,
    String field1,
  ) = JsModule_Code;
  const factory JsModule.path(
    String field0,
    String field1,
  ) = JsModule_Path;

  static JsModule fromCode({required String module, required String code}) =>
      LibFjs.instance.api
          .crateApiJsJsModuleFromCode(module: module, code: code);

  static JsModule fromPath({required String module, required String path}) =>
      LibFjs.instance.api
          .crateApiJsJsModuleFromPath(module: module, path: path);

  factory JsModule({required String module, String? code, String? path}) =>
      LibFjs.instance.api
          .crateApiJsJsModuleNew(module: module, code: code, path: path);
}
